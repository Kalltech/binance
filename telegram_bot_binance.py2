#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Press Ctrl-C on the command line or send a signal to the process to stop the
bot.
"""

from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackQueryHandler
import telegram
from telegram import ReplyKeyboardMarkup,  InlineKeyboardMarkup,  InlineKeyboardButton
import logging
import os
import datetime
import time
#import pickle
import string,  re
import ConfigParser
import json
import glob

load_params = ConfigParser.ConfigParser()
load_params.read("binance_api.ini")
#load_params_bitmex = ConfigParser.ConfigParser()
#load_params_bitmex.read("bitmex_api.ini")
json_stats="sell_stats.json"

cwd = os.getcwd()
api_path=cwd+"/"
# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
level=logging.INFO)

hot = u'\U0001F525'             # Code: 904
clouds = u'\U00002601'          # Code: 802-803-804 clouds general
croix = u'\U0000274C'          # Code: 802-803-804 clouds general
interrogation = u'\U00002753'          # Code: 802-803-804 clouds general

signal_dict = {}

def ConfigSectionMap(section, Config):
  dict1 = {}
  options = Config.options(section)
  for option in options:    
    try:
      dict1[option] = Config.get(section, option)
      if dict1[option] == -1:
         print("skip: %s" % option)
    except:
      print("exception on %s!" % option)
      dict1[option] = None
  return dict1

def extract_numbers(extract_numbers_str, **kwargs):
    extract_numbers_array=re.findall(r'\d+',extract_numbers_str)
#    print extract_numbers_array
    global signal_dict
#    print signal_dict
    if extract_numbers_array:
        if extract_numbers_array[0]=="0":
            return float8f(str(extract_numbers_array[0]+"."+extract_numbers_array[1]))
        elif "USD" in signal_dict['C']:
            return str(extract_numbers_array[0])
        elif kwargs.get("satoshi_extract_numbers")==1:
            temp=8-len(str(extract_numbers_array[0]))
            temp2=""
            for x in range(1, temp):
                temp2=temp2+"0"
#            print "0."+temp2+str(extract_numbers_array[0])
            return "0."+temp2+str(extract_numbers_array[0])
        else:
            return "vide"
    else:
        return "vide"

def get_price_type(get_price_type_str, get_price_type_valeurs, **kwargs):
#    for key, value in kwargs.items():
#        setattr(self, key, value)
    for valeur in get_price_type_valeurs:
        if valeur in get_price_type_str:
#            print get_price_type_str.replace(valeur, "")
            return extract_numbers(get_price_type_str.replace(valeur, ""), satoshi_extract_numbers=kwargs.get("satoshi"))
    return "vide"

global my_telegram_id
my_telegram_id = ConfigSectionMap("BINANCE_API", load_params)['my_telegram_id']
percentage_max_hodl_sl = float(ConfigSectionMap("BINANCE_API", load_params)['percentage_max_hodl_sl'])
percentage_sl_upside = float(ConfigSectionMap("BINANCE_API", load_params)['percentage_sl_upside'])
percentage_control_balance = float(ConfigSectionMap("BINANCE_API", load_params)['percentage_control_balance'])

def findkeys(d, findkeys_str):
    for key in d.keys():
        if findkeys_str in key:
            return 1
    return 0
    
def float0f(float0f_value):
    return format(float(float0f_value), '.0f')

def stats():
    sell_stats_file=cwd+"/"+json_stats
    stats_str=""
    with open(sell_stats_file) as json_data:
        dct_sell_stats = json.load(json_data)
        json_data.close()
        sum_GainUSD_today=0
        today=datetime.datetime.now().strftime("%Y-%m-%d")
        if findkeys(dct_sell_stats, today):
            dct_today=dct_sell_stats.get(today)
            for key in dct_today.keys():
                sum_GainUSD_today=sum_GainUSD_today+float(dct_today[key]["gain_USD"])
        stats_str= "Gain today $:"+float0f(sum_GainUSD_today)
        sum_GainUSD_week=0
        for x in range(0, 8):
            day=datetime.datetime.now()-datetime.timedelta(days=int(x))
            day=str(day.strftime("%Y-%m-%d"))
            if findkeys(dct_sell_stats, day):
                dct_day=dct_sell_stats.get(day)
                for key in dct_day.keys():
                    sum_GainUSD_week=sum_GainUSD_week+float(dct_day[key]["gain_USD"])
        stats_str= stats_str+"\nGain last 7 days $:"+float0f(sum_GainUSD_week)
        sum_GainUSD_month=0
        for x in range(0, 32):
            day=datetime.datetime.now()-datetime.timedelta(days=int(x))
            day=str(day.strftime("%Y-%m-%d"))
            if findkeys(dct_sell_stats, day):
                dct_day=dct_sell_stats.get(day)
                for key in dct_day.keys():
                    sum_GainUSD_month=sum_GainUSD_month+float(dct_day[key]["gain_USD"])
        stats_str= stats_str+"\nGain last 31 days $:"+float0f(sum_GainUSD_month)
    return stats_str
logger = logging.getLogger(__name__)

# Define a few command handlers. These usually take the two arguments bot and
# update. Error handlers also receive the raised TelegramError object in error.

def float8f(float8f_value):
    return format(float(float8f_value), '.8f')

def start(bot, update):
    """Send a message when the command /start is issued."""
    update.message.reply_text('Hi!')

def Detail_Status(bot, update):
    """Send a message when the command /start is issued."""
    update.message.reply_text('Hi!')

def menu(bot):
    """Send a message when the command /menu is issued."""
#    update.message.reply_text('menu activating!')
    menu_keyboard = [['Status', 'Stats'], ['StartAutotrade', 'StopAutotrade'], ['Kill', 'Panicsell'], ['/help']]
    menu_markup = ReplyKeyboardMarkup(menu_keyboard, one_time_keyboard=False, resize_keyboard=True)
    global my_telegram_id
    try:
        bot.send_message(my_telegram_id, text='Select button:', reply_markup=menu_markup)
    except:
        print "Timeout telegram"

def build_menu(buttons,
               n_cols,
               header_buttons=None,
               footer_buttons=None):
    menu = [buttons[i:i + n_cols] for i in range(0, len(buttons), n_cols)]
    if header_buttons:
        menu.insert(0, header_buttons)
    if footer_buttons:
        menu.append(footer_buttons)
#    print menu
    return menu

def button(bot, update):
    query = update.callback_query
    print query.data
    str_msg=""
    if "panicsell:" in query.data:
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename and query.data.replace("panicsell:","") in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                dct_FILE['panicsell']=1
                save_obj(dct_FILE, dct_FILE.get("filename"))
                str_msg=str_msg+"\n"+"Panic sell sent:"+query.data.replace("panicsell:","")
        if str_msg<>"":
            bot.editMessageText(text=str_msg,
                                chat_id=query.message.chat_id,
                                message_id=query.message.message_id)
    elif "kill:" in query.data:
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and query.data.replace("kill:","") in filename:
                print(api_path+"trades/"+filename)
                os.rename(api_path+"trades/"+filename, api_path+"old/"+filename)
                str_msg=str_msg+"\n"+"Kill ok:"+filename
        if "signals/" in query.data.replace("kill:",""):
            filepath=query.data.replace("kill:","")
            print(filepath)
            os.rename(filepath, filepath.replace("signals/","old/"))
            str_msg=str_msg+"\n"+"Kill ok: "+filepath.replace(api_path+"signals/","")
        if str_msg<>"":
            bot.editMessageText(text=str_msg,
                                    chat_id=query.message.chat_id,
                                    message_id=query.message.message_id)
    elif "signals/" in query.data:
        for filename in os.listdir(api_path+"signals/"):
            if query.data in api_path+"signals/"+filename:
                print(api_path+"signals/"+filename)
                text_file = open(api_path+"signals/"+filename, "r")
                str_msg=text_file.read()
                text_file.close()
    elif ".bitmex_trades" in query.data:
        print(api_path+"bitmex_trades/")
        for filename in os.listdir(api_path+"bitmex_trades/"):
            if ".json" in filename and not ".log" in filename and query.data.replace(".bitmex_trades", "") in filename:
                print(api_path+"bitmex_trades/"+filename)
                dct_FILE=load_obj(api_path+"bitmex_trades/"+filename)
                if dct_FILE.has_key('order_BUY_FILLED'):
                    percentage_gain_lost=float(dct_FILE['bitmex_price'])/float(dct_FILE['order_BUY_FILLED']['price'])*100-100
                    if dct_FILE['POS']=="short":percentage_gain_lost=-percentage_gain_lost
                    percentage_gain_lost=format(percentage_gain_lost, '.2f')
                    last_sl_stop=dct_FILE['SL']
                    if dct_FILE.has_key('order_T2_SL') or dct_FILE.has_key('order_T1_SL'): last_sl_stop=dct_FILE['last_SL_stopPrice']
                    status_dict="Buy price:   "+str(float8f(dct_FILE['order_BUY_FILLED']['price']))\
                        +"\n"+"Last price:  "+str(float8f(dct_FILE['bitmex_price']))\
                        +"\n"+"Last SL :     "+str(float8f(last_sl_stop))\
                        +"\n"+"Gain/Lost: "+str(percentage_gain_lost)+"%"\
                        +"\n"+"POS: "+str(dct_FILE['POS'])\
                        +"\n"+"T1: "+str(float8f(dct_FILE['T1']))\
                        +"\n"+"T2: "+str(float8f(dct_FILE['T2']))\
                        +"\n"+"T3: "+str(float8f(dct_FILE['T3']))\
                        +"\nLevel: "+dct_FILE['last_order_level']
                    str_msg=str_msg+"\n"+filename+"\n"+str(status_dict)
                else:
                    str_msg=str_msg+"\n"+filename+"\n"+"Order not filled"
    else:
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename and query.data in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                if dct_FILE.has_key('order_BUY_FILLED'):
                    percentage_gain_lost=float(dct_FILE['binance_price'])/float(dct_FILE['order_BUY_FILLED']['price'])*100-100
                    percentage_gain_lost=format(percentage_gain_lost, '.2f')
                    last_sl_stop=dct_FILE['SL']
                    if dct_FILE.has_key('order_T2_SL') or dct_FILE.has_key('order_T1_SL'): last_sl_stop=dct_FILE['last_SL_stopPrice']
                    status_dict="Buy price:   "+str(float8f(dct_FILE['order_BUY_FILLED']['price']))\
                        +"\n"+"Last price:  "+str(float8f(dct_FILE['binance_price']))\
                        +"\n"+"Last SL :     "+str(float8f(last_sl_stop))\
                        +"\n"+"Gain/Lost: "+str(percentage_gain_lost)+"%"\
                        +"\n"+"T1: "+str(float8f(dct_FILE['T1']))\
                        +"\n"+"T2: "+str(float8f(dct_FILE['T2']))\
                        +"\n"+"T3: "+str(float8f(dct_FILE['T3']))\
                        +"\nLevel: "+dct_FILE['last_order_level']
                    str_msg=str_msg+"\n"+filename+"\n"+str(status_dict)
                else:
                    str_msg=str_msg+"\n"+filename+"\n"+"Order not filled"
    if str_msg<>"":
        bot.editMessageText(text=str_msg,
                            chat_id=query.message.chat_id,
                            message_id=query.message.message_id)

def help(bot, update):
    """Send a message when the command /help is issued."""
    update.message.reply_text('Help!\nPause:5 Met en pause pour 5min\nStatus Donne le status de chaque trade\nstopautotrade or startautotrade: Disable or enable auto_trade in INI\nStats Donne les stats de vente\nKill:XLMBTC Stop la surveillance de la paire\nSignal... Met en fil d attente la position selon les valeurs\n')

def echo(bot, update):
    """Echo the user message."""
    print "BEGIN response"
    global signal_dict
    global my_telegram_id
    text_sent=update.message.text.lower()
    printable = set(string.printable)
    text_sent=filter(lambda x: x in printable, text_sent)
    a_channel=text_sent.split("\n")
    print a_channel
    channel=""
    if "PeerChannel(channel_id=".lower() in a_channel[0] or "PeerUser(user_id=".lower() in a_channel[0]:
        channel=a_channel[0]
#    print text_sent
#    print text_sent[:5]
    if "pause:" in text_sent:
        print "Create pause.txt"
        a_pause=text_sent.split("pause:")
        print a_pause[1]
        text_file = open("pause.txt", "w")
        f_time=datetime.datetime.now().replace(microsecond=0)+datetime.timedelta(minutes=int(a_pause[1]))
        text_file.write(str(f_time))
        text_file.close()
        update.message.reply_text("Pause until: "+str(f_time))
    elif text_sent=="stats":
        sell_stats_file=cwd+"/"+json_stats
        if not os.path.isfile(sell_stats_file):
            update.message.reply_text("Stats empty")
        else:
            update.message.reply_text(stats())
    elif text_sent[:5]=="hodl:":
        hodl_dict = {}
        hodl_dict['symbol'] = text_sent.replace("hodl:", "")
        hodl_dict['symbol'] = hodl_dict['symbol'].upper()
        hodl_dict['SL'] = 'init'
        hodl_dict['last_orderId'] = 'init'
        hodl_dict['max_price'] = 'init'
        hodl_dict['last_order_level'] = 'init'
        hodl_dict['executedQty_creation'] = 0
        hodl_dict['executedQty_vendu'] = 0
        hodl_dict['filename'] = 'init'
        hodl_dict['dictToBeFilled'] = {}
        hodl_dict['percentage_max_hodl_sl']=percentage_max_hodl_sl
        hodl_dict['percentage_sl_upside']=percentage_sl_upside
        hodl_dict['percentage_control_balance']=percentage_control_balance
        hodl_dict['CHNL'] = channel

        print("creation hodl file:"+api_path+"hodl/"+hodl_dict['symbol'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S")+".json")
        save_obj(hodl_dict, api_path+"hodl/"+hodl_dict['symbol'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S")+".json")

    elif text_sent=="stopautotrade":
            load_params.read("binance_api.ini")
            load_params.set('BINANCE_API','auto_trade',0)
            cfgfile = open("binance_api.ini",'w')
            load_params.write(cfgfile)
            cfgfile.close()
            update.message.reply_text("OK")
    elif text_sent=="startautotrade":
            load_params.read("binance_api.ini")
            load_params.set('BINANCE_API','auto_trade',1)
            cfgfile = open("binance_api.ini",'w')
            load_params.write(cfgfile)
            cfgfile.close()
            update.message.reply_text("OK")
    elif text_sent=="status":
#        print "status"
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+"signals/"):
            print(api_path+"signals/"+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data=api_path+"signals/"+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='All signals:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                executedDate_creation= dct_FILE['executedDate_creation']
                f_time=datetime.datetime.strptime(executedDate_creation.replace("_", " "), '%Y-%m-%d %H.%M.%S')
                diff_time=datetime.datetime.now().replace(microsecond=0)-f_time
#                print diff_time.days
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
#                print status_dict
                status_dict[dct_FILE.get("symbol")+"Days"]=str(diff_time.days)
                status_dict[dct_FILE.get("symbol")+"LL"]=dct_FILE['last_order_level'].replace("order_", "")
#                print status_dict
        if status_dict<>{}:
            for symbols in sorted(status_dict):
#                print symbols
                if not "Days" in symbols and not "LL" in symbols:
                    button_list.append(InlineKeyboardButton(symbols.replace("BTC", "")+":"+str(status_dict[symbols+"LL"])+":"+str(status_dict[symbols+"Days"])+"d", callback_data=symbols))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        list_of_files = glob.glob(api_path+"logs/*")
        latest_file = max(list_of_files, key=os.path.getctime)
        load_params.read("binance_api.ini")
        auto_trade = ConfigSectionMap("BINANCE_API", load_params)['auto_trade']
#        update.message.reply_text("Dernier log:"+time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime(latest_file)))+"\nAutotrade:"+str(auto_trade))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='All trades:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+"bitmex_trades/"):
            if ".json" in filename and not ".log" in filename:
                print(api_path+"bitmex_trades/"+filename)
                dct_FILE=load_obj(api_path+"bitmex_trades/"+filename)
                executedDate_creation= dct_FILE['executedDate_creation']
                f_time=datetime.datetime.strptime(executedDate_creation.replace("_", " "), '%Y-%m-%d %H.%M.%S')
                diff_time=datetime.datetime.now().replace(microsecond=0)-f_time
#                print diff_time.days
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['bitmex_price']))+"\n"+dct_FILE['last_order_level']
#                print status_dict
                status_dict[dct_FILE.get("symbol")+"Days"]=str(diff_time.days)
                status_dict[dct_FILE.get("symbol")+"LL"]=dct_FILE['last_order_level'].replace("order_", "")
#                print status_dict
        if status_dict<>{}:
            for symbols in sorted(status_dict):
#                print symbols
                if not "Days" in symbols and not "LL" in symbols:
                    button_list.append(InlineKeyboardButton(symbols+":"+str(status_dict[symbols+"LL"])+":"+str(status_dict[symbols+"Days"])+"d", callback_data=symbols+".bitmex_trades"))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        list_of_files = glob.glob(api_path+"logs/*")
        latest_file = max(list_of_files, key=os.path.getctime)
        load_params.read("binance_api.ini")
        auto_trade = ConfigSectionMap("BINANCE_API", load_params)['auto_trade']
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='All bitmex_trades:', reply_markup=reply_markup)
        update.message.reply_text("Dernier log:"+time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime(latest_file)))+"\n"+"Derniere erreur:"+time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime("whatchdog_error.log")))+"\nAutotrade:"+str(auto_trade))
    elif text_sent=="panicsell":
        print "panicsell"
        status_dict = {}
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
        button_list = []
        for symbols in sorted(status_dict):
            button_list.append(InlineKeyboardButton(hot+symbols, callback_data="panicsell:"+symbols))
        reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        bot.send_message(my_telegram_id, text='Which panicsell trades:', reply_markup=reply_markup)
    elif text_sent=="kill":
        print "kill"
        status_dict = {}
        button_list = []
        reply_markup = ""
        for filename in os.listdir(api_path+"bitmex_signals/"):
            print(api_path+"bitmex_signals/"+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data="kill:"+api_path+"bitmex_signals/"+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='Which kill bitmex signals:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup = ""
        for filename in os.listdir(api_path+"signals/"):
            print(api_path+"signals/"+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data="kill:"+api_path+"signals/"+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='Which kill binance signals:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup = ""
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
        button_list = []
        reply_markup = ""
        for symbols in sorted(status_dict):
            button_list.append(InlineKeyboardButton(croix+symbols, callback_data="kill:"+symbols))
        reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='Which kill binance trades:', reply_markup=reply_markup)

    elif "PeerChannel(channel_id=1229891129)".lower() in text_sent or "PeerChannel(channel_id=1114421815)".lower() in text_sent or "Test_sl".lower() in text_sent:
        print "GPS"
        symbol_dict=load_obj("binance_prices.json")
#        symbol_dict = ['XBTUSD','.XRPXBT','.XRPXBT30M','.EVOL7D','.EOSXBT','.EOSXBT30M','.JPYBON','.JPYBON2H','.JPYBON8H','.BCHXBT','.BCHXBT30M','.KRWBON','.KRWBON2H','.KRWBON8H','.XBTKRWPI','.XBTKRWPI2H','.XBTKRWPI8H','.XBTKRW','.XBTKRW30M','.ADAXBT','.ADAXBT30M','.TRXXBT','.TRXXBT30M','.BADAXBT','.BADAXBT30M','.BBCHXBT','.BBCHXBT30M','.BEOSXBT','.BEOSXBT30M','.BXRPXBT','.BXRPXBT30M','BCHU18','ADAU18','EOSU18','XRPU18','TRXU18','XRPZ18','BCHZ18','ADAZ18','EOSZ18','TRXZ18','BTC/KRW','.XBT','.XBT30M','.XBTBON','.XBTBON8H','.XBTUSDPI','.XBTUSDPI8H','.XBTBON2H','.XBTUSDPI2H','.BXBT','.BXBT30M','.XBTJPY','.XBTJPY30M','.BXBTJPY','.BXBTJPY30M','.XBTJPYPI','.XBTJPYPI2H','.XBTJPYPI8H','.BVOL','.BVOL24H','.BVOL7D','.ETHXBT','.ETHXBT30M','.ETHXBTPI','.ETHXBTPI8H','.ETHBON','.ETHBON2H','.ETHBON8H','.ETHXBTPI2H','.BETH','.BETH30M','.ETHUSDPI','.ETHUSDPI2H','.ETHUSDPI8H','.BETHXBT','.BETHXBT30M','.LTCXBT','.LTCXBT30M','.BLTCXBT','.BLTCXBT30M','.USDBON','.USDBON8H','.USDBON2H','BTC/USD','XBT7D_U105','XBT7D_D95','XBTU18','XBTZ18','XBTH19','BTC/JPY','ETH/BTC','ETH/USD','ETHU18','ETHZ18','LTCU18','LTCZ18']
#        global signal_dict
        signal_dict = {}
        signal_dict['C'] = 'init'
        signal_dict['AC'] = 'init'
        signal_dict['T1'] = 'init'
        signal_dict['T2'] = 'init'
        signal_dict['T3'] = 'init'
        signal_dict['SL'] = 'init'
        signal_dict['USD'] = 'init'
        signal_dict['CHNL'] = channel
        
#        signal_dict['BAD'] = 'init'
        lines=text_sent
        lines=lines.splitlines()
        for line in lines:
            line=line.replace(" ", "")
            line=line.replace("/", "")
            line=line.replace("#", ":")
            line=line.replace("$", "")
            line=line.replace("~", ":")
            print line
#            print line.upper()+"BTC"
            if line.upper()+"BTC" in symbol_dict and signal_dict['C']=="init":
                signal_dict['C'] = line.upper()+"BTC"
            if "coin:" in line and signal_dict['C']=="init":
                a_coin=line.split("coin:")
                signal_dict['C'] = a_coin[1].upper()+"BTC"
            a={"buy", "buyunder", "buy:"}
            if any(x in line for x in a) and signal_dict['AC']=="init":
                signal_dict['AC'] = get_price_type(line, a, satoshi=1)
            if "sell:" in line:
                a_sell=line.split("sell:")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = get_price_type("t1:"+a_sell[0], {"t1", "target1"}, satoshi=1)
                signal_dict['T2'] = get_price_type("t2:"+a_sell[1], {"t2", "target2"}, satoshi=1)
                signal_dict['T3'] = get_price_type("t3:"+a_sell[2], {"t3", "target3"}, satoshi=1)
            if "shorttermtargets:" in line:
                a_sell=line.split("shorttermtargets:")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = get_price_type("t1:"+a_sell[0], {"t1", "target1"}, satoshi=1)
                signal_dict['T2'] = get_price_type("t2:"+a_sell[1], {"t2", "target2"}, satoshi=1)
                signal_dict['T3'] = get_price_type("t3:"+a_sell[2], {"t3", "target3"}, satoshi=1)
            a={"target1:", "t1:"}
            if any(x in line for x in a) and signal_dict['T1']=="init":
                signal_dict['T1'] = get_price_type(line, a, satoshi=1)
            a={"target2:", "t2:"}
            if any(x in line for x in a) and signal_dict['T2']=="init":
                signal_dict['T2'] = get_price_type(line, a, satoshi=1)
            a={"target3:", "t3:"}
            if any(x in line for x in a) and signal_dict['T3']=="init":
                signal_dict['T3'] = get_price_type(line, a, satoshi=1)
            a={"stop:", "stoploss", "stoplimit:", "stop-loss:"}
            if any(x in line for x in a) and signal_dict['SL']=="init":
                signal_dict['SL'] = get_price_type(line, a, satoshi=1)

        print signal_dict
        key_not_find=0
        str_file="[TRADE]\n"
        if signal_dict['USD']=="init": signal_dict['USD'] = ConfigSectionMap("BINANCE_API", load_params)['usd_to_bet']
        for key, value in sorted(signal_dict.items()):
            if value == 'init' or value == 'vide':
                update.message.reply_text("Valeur non trouvee:"+key)
                key_not_find=1
            else:
                str_file=str_file+key.upper()+":"+value.strip()+"\n"

        if key_not_find<>1:
            if not float(signal_dict['SL'])<=float(signal_dict['AC'])<=float(signal_dict['T1'])<=float(signal_dict['T2'])<=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            else:
                text_file = open(api_path+"/signals/"+signal_dict['C'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S"), "w")
                text_file.write(str_file)
                text_file.close()
                update.message.reply_text("Signal resolu:\n"+str_file)
        else:
            update.message.reply_text("Signal non resolu, format:\nXLMBTC\nBuy:0.01\nSell: 0.02-0.03-0.04\nStop:0.005\nUSD:100\nOu format:\nXLMBTC\nBuy:0.01\nT1:0.02\nT2:0.03\nT3:0.04\nStop Loss:0.005\nUSD:100")
    elif "PeerChannel(channel_id=1321818269)".lower() in text_sent:
        print "bitmex"
        load_params_bitmex = ConfigParser.ConfigParser()
        load_params_bitmex.read("bitmex_api.ini")
        symbol_dict=load_obj("bitmex_contracts.json")

#        symbol_dict = ['XBTUSD','.XRPXBT','.XRPXBT30M','.EVOL7D','.EOSXBT','.EOSXBT30M','.JPYBON','.JPYBON2H','.JPYBON8H','.BCHXBT','.BCHXBT30M','.KRWBON','.KRWBON2H','.KRWBON8H','.XBTKRWPI','.XBTKRWPI2H','.XBTKRWPI8H','.XBTKRW','.XBTKRW30M','.ADAXBT','.ADAXBT30M','.TRXXBT','.TRXXBT30M','.BADAXBT','.BADAXBT30M','.BBCHXBT','.BBCHXBT30M','.BEOSXBT','.BEOSXBT30M','.BXRPXBT','.BXRPXBT30M','BCHU18','ADAU18','EOSU18','XRPU18','TRXU18','XRPZ18','BCHZ18','ADAZ18','EOSZ18','TRXZ18','BTC/KRW','.XBT','.XBT30M','.XBTBON','.XBTBON8H','.XBTUSDPI','.XBTUSDPI8H','.XBTBON2H','.XBTUSDPI2H','.BXBT','.BXBT30M','.XBTJPY','.XBTJPY30M','.BXBTJPY','.BXBTJPY30M','.XBTJPYPI','.XBTJPYPI2H','.XBTJPYPI8H','.BVOL','.BVOL24H','.BVOL7D','.ETHXBT','.ETHXBT30M','.ETHXBTPI','.ETHXBTPI8H','.ETHBON','.ETHBON2H','.ETHBON8H','.ETHXBTPI2H','.BETH','.BETH30M','.ETHUSDPI','.ETHUSDPI2H','.ETHUSDPI8H','.BETHXBT','.BETHXBT30M','.LTCXBT','.LTCXBT30M','.BLTCXBT','.BLTCXBT30M','.USDBON','.USDBON8H','.USDBON2H','BTC/USD','XBT7D_U105','XBT7D_D95','XBTU18','XBTZ18','XBTH19','BTC/JPY','ETH/BTC','ETH/USD','ETHU18','ETHZ18','LTCU18','LTCZ18']
        signal_dict = {}
        signal_dict['C'] = 'init'
        signal_dict['POS'] = 'init'
        signal_dict['AC'] = 'init'
        signal_dict['T1'] = 'init'
        signal_dict['T2'] = 'init'
        signal_dict['T3'] = 'init'
        signal_dict['SL'] = 'init'
        signal_dict['USD'] = 'init'
        signal_dict['CHNL'] = channel
#        signal_dict['BAD'] = 'init'
        lines=text_sent
        lines=lines.splitlines()
        for line in lines:
            line=line.replace(" ", "")
            line=line.replace("/", "")
            line=line.replace("#", ":")
            line=line.replace("$", "")
#            print line
            if (line.upper() in symbol_dict or 'XBTUSD' in line.upper() or 'ETHUSD' in line.upper()) and signal_dict['C']=="init":
                signal_dict['C'] = line.upper()
            if "position:" in line and signal_dict['POS']=="init":
                signal_dict['POS'] = line.replace("position:", "")
            a={"buyaboveorin:", "buybeloworin:"}
            if any(x in line for x in a) and signal_dict['AC']=="init":
                signal_dict['AC'] = get_price_type(line, a)
            a={"target1:", "t1:"}
            if any(x in line for x in a) and signal_dict['T1']=="init":
                signal_dict['T1'] = get_price_type(line, a)
            a={"target2:", "t2:"}
            if any(x in line for x in a) and signal_dict['T2']=="init":
                signal_dict['T2'] = get_price_type(line, a)
            a={"target3:", "t3:"}
            if any(x in line for x in a) and signal_dict['T3']=="init":
                signal_dict['T3'] = get_price_type(line, a)
            a={"stop:", "stoploss:", "stoplimit:", "stop-loss:"}
            if any(x in line for x in a) and signal_dict['SL']=="init":
                signal_dict['SL'] = get_price_type(line, a)
            a={"usd:", "usdt:"}
            if any(x in line for x in a) and signal_dict['USD']=="init":
                for x in a:
                    if x in line:
                        a_usd=line.split(x)
                        signal_dict['USD'] = a_usd[1]

        print signal_dict
        key_not_find=0
        str_file="[TRADE]\n"
        if signal_dict['USD']=="init": signal_dict['USD'] = ConfigSectionMap("BITMEX_API", load_params_bitmex)['usd_to_bet']
        for key, value in sorted(signal_dict.items()):
            if value == 'init' or value == 'vide':
                update.message.reply_text("Valeur non trouvee:"+key)
                key_not_find=1
            else:
                str_file=str_file+key.upper()+":"+value.strip()+"\n"

        if key_not_find<>1:
            if signal_dict['POS'] == "long" and not float(signal_dict['SL'])<=float(signal_dict['AC'])<=float(signal_dict['T1'])<=float(signal_dict['T2'])<=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            if signal_dict['POS'] == "short" and not float(signal_dict['SL'])>=float(signal_dict['AC'])>=float(signal_dict['T1'])>=float(signal_dict['T2'])>=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            else:
                text_file = open(api_path+"/bitmex_signals/"+signal_dict['C'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S"), "w")
                text_file.write(str_file)
                text_file.close()
                update.message.reply_text("Signal resolu:\n"+str_file)
        else:
            update.message.reply_text("Signal non resolu, format:\nXLMBTC\nBuy:0.01\nSell: 0.02-0.03-0.04\nStop:0.005\nUSD:100\nOu format:\nXLMBTC\nBuy:0.01\nT1:0.02\nT2:0.03\nT3:0.04\nStop Loss:0.005\nUSD:100")
    elif "btc" in text_sent or "coin:" in text_sent:
        print "signal"
        signal_dict = {}
        signal_dict['C'] = 'init'
        signal_dict['AC'] = 'init'
        signal_dict['T1'] = 'init'
        signal_dict['T2'] = 'init'
        signal_dict['T3'] = 'init'
        signal_dict['SL'] = 'init'
        signal_dict['USD'] = 'init'
        signal_dict['CHNL'] = channel
#        signal_dict['BAD'] = 'init'
        lines=text_sent
        lines=lines.splitlines()
        for line in lines:
            line=line.replace(" ", "")
            line=line.replace("/", "")
            line=line.replace("#", ":")
            line=line.replace("$", "")
#            line=line.replace("coin:", "")
#            print(line)
#Crypto Signalist Pro
            if "btc" in line and signal_dict['C']=="init":
                signal_dict['C'] = line.upper()
                if signal_dict['C'].find("("):
                    a_symbol=signal_dict['C']
                    a_symbol=a_symbol.split('(', 1)[0]
                    signal_dict['C'] = a_symbol
                if signal_dict['C'].find("-"):
                    a_symbol=signal_dict['C']
                    a_symbol=a_symbol.split('-', 1)[0]
                    signal_dict['C'] = a_symbol
            if "coin:" in line and signal_dict['C']=="init":
                a_usd=line.split("coin:")
                signal_dict['C'] = a_usd[1].upper()+"BTC"
            if "usd" in line:
                a_usd=line.split("usd:")
                signal_dict['USD'] = a_usd[1]
            if "sell:" in line:
                a_sell=line.split("sell:")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = float8f(float(a_sell[0]))
                signal_dict['T2'] = float8f(float(a_sell[1]))
                signal_dict['T3'] = float8f(float(a_sell[2]))
            if "t1:" in line and "t2:" in line and "t3:" in line :
                a_t1t2t3=line.replace("t1","")
                a_t1t2t3=a_t1t2t3.replace("t2","")
                a_t1t2t3=a_t1t2t3.replace("t3","")
                a_t1t2t3=a_t1t2t3.split(":")
                signal_dict['T1'] = float8f(float(a_t1t2t3[1]))
                signal_dict['T2'] = float8f(float(a_t1t2t3[2]))
                signal_dict['T3'] = float8f(float(a_t1t2t3[3]))
#Signal Profits
            else:
                a={"target1:", "t1:"}
                if any(x in line for x in a):
                    if signal_dict['T1']=="init":
                        signal_dict['T1'] = get_price_type(line, a)
                    else:
                        signal_dict['T3'] = get_price_type(line, a)
                a={"target2:", "t2:"}
                if any(x in line for x in a) and signal_dict['T2']=="init":
                    signal_dict['T2'] = get_price_type(line, a)
                a={"target3:", "t3:"}
                if any(x in line for x in a):
                    signal_dict['T3'] = get_price_type(line, a)
            a={"buy:", "buyzone:", "buybelow:", "buybeloworcloseto:", "entryzone:"}
            if any(x in line for x in a) and signal_dict['AC']=="init":
                signal_dict['AC'] = get_price_type(line, a)
            a={"stop:", "stoploss:", "stoplimit:", "stop-loss:"}
            if any(x in line for x in a) and signal_dict['SL']=="init":
                signal_dict['SL'] = get_price_type(line, a)
            a={"usd:", "usdt:"}
            if any(x in line for x in a) and signal_dict['USD']=="init":
                for x in a:
                    if x in line:
                        a_usd=line.split(x)
                        signal_dict['USD'] = a_usd[1]
                
        print signal_dict
        key_not_find=0
        str_file="[TRADE]\n"
        if signal_dict['USD']=="init": signal_dict['USD'] = ConfigSectionMap("BINANCE_API", load_params)['usd_to_bet']
        for key, value in sorted(signal_dict.items()):
            if value == 'init' or value == 'vide':
                update.message.reply_text("Valeur non trouvee:"+key)
                key_not_find=1
            else:
                str_file=str_file+key.upper()+":"+value.strip()+"\n"

        if key_not_find<>1:
            if not float(signal_dict['SL'])<=float(signal_dict['AC'])<=float(signal_dict['T1'])<=float(signal_dict['T2'])<=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            else:
                text_file = open(api_path+"/signals/"+signal_dict['C'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S"), "w")
                text_file.write(str_file)
                text_file.close()
                update.message.reply_text("Signal resolu:\n"+str_file)
        else:
            update.message.reply_text("Signal non resolu, format:\nXLMBTC\nBuy:0.01\nSell: 0.02-0.03-0.04\nStop:0.005\nUSD:100\nOu format:\nXLMBTC\nBuy:0.01\nT1:0.02\nT2:0.03\nT3:0.04\nStop Loss:0.005\nUSD:100")
#            print str_file
    else:
        update.message.reply_text("I dont understand")
#    menu(bot)
    print "END response"
    
def load_obj(name ):
#    with open(name, 'rb') as f:
#        debugapp(str(sys._getframe().f_code.co_name)+"|"+"Ouvre l objet depuis: "+name,debugapp_DebugLevel="DEBUG", debugapp_logger=logger)
#        return pickle.load(f)
    with open(name) as json_data:
        dct_load_obj = json.load(json_data)
        json_data.close()
        return dct_load_obj

def save_obj(obj, name ):
    if not ".json" in name and not ".laststate" in name:
#        with open(name, 'wb') as f:
#        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)
            pass
    else:
        save_obj_out_file = open(name,"w")
        json.dump(obj,save_obj_out_file, indent=4, sort_keys=True)                                    
        save_obj_out_file.close()

def error(bot, update, error):
    """Log Errors caused by Updates."""
    logger.warning('Update "%s" caused error "%s"', update, error)

def main():
    """Start the bot."""
    # Create the EventHandler and pass it your bot's token.
    my_telegram_bot_token = ConfigSectionMap("BINANCE_API", load_params)['my_telegram_bot_token']
    global updater
    updater = Updater(my_telegram_bot_token)
    bot = telegram.Bot(my_telegram_bot_token)

    menu(bot)

    # Get the dispatcher to register handlers
    dp = updater.dispatcher

    # on different commands - answer in Telegram
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("menu", menu))
    dp.add_handler(CommandHandler("help", help))

    # on noncommand i.e message - echo the message on Telegram
    dp.add_handler(MessageHandler(Filters.text, echo))
    dp.add_handler(CallbackQueryHandler(button))

    # log all errors
    dp.add_error_handler(error)

    # Start the Bot
    updater.start_polling()
    
    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()

print "Starting Bot"
if __name__ == '__main__':
    main()
