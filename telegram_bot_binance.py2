#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Press Ctrl-C on the command line or send a signal to the process to stop the
bot.
"""

from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackQueryHandler
import telegram
from telegram import ReplyKeyboardMarkup,  InlineKeyboardMarkup,  InlineKeyboardButton
import logging
import os
import datetime
import time
#import pickle
import string
import ConfigParser
import json
import glob

load_params = ConfigParser.ConfigParser()
load_params.read("binance_api.ini")
json_stats="sell_stats.json"

cwd = os.getcwd()
api_path=cwd+"/"
# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
level=logging.INFO)

hot = u'\U0001F525'             # Code: 904
clouds = u'\U00002601'          # Code: 802-803-804 clouds general
croix = u'\U0000274C'          # Code: 802-803-804 clouds general
interrogation = u'\U00002753'          # Code: 802-803-804 clouds general

def ConfigSectionMap(section, Config):
  dict1 = {}
  options = Config.options(section)
  for option in options:    
    try:
      dict1[option] = Config.get(section, option)
      if dict1[option] == -1:
         print("skip: %s" % option)
    except:
      print("exception on %s!" % option)
      dict1[option] = None
  return dict1

global my_telegram_id
my_telegram_id = ConfigSectionMap("BINANCE_API", load_params)['my_telegram_id']

def findkeys(d, findkeys_str):
    for key in d.keys():
        if findkeys_str in key:
            return 1
    return 0
    
def float0f(float0f_value):
    return format(float(float0f_value), '.0f')

def stats():
    sell_stats_file=cwd+"/"+json_stats
    stats_str=""
    with open(sell_stats_file) as json_data:
        dct_sell_stats = json.load(json_data)
        json_data.close()
        sum_GainUSD_today=0
        today=datetime.datetime.now().strftime("%Y-%m-%d")
        if findkeys(dct_sell_stats, today):
            dct_today=dct_sell_stats.get(today)
            for key in dct_today.keys():
                sum_GainUSD_today=sum_GainUSD_today+float(dct_today[key]["gain_USD"])
        stats_str= "Gain today $:"+float0f(sum_GainUSD_today)
        sum_GainUSD_week=0
        for x in range(0, 8):
            day=datetime.datetime.now()-datetime.timedelta(days=int(x))
            day=str(day.strftime("%Y-%m-%d"))
            if findkeys(dct_sell_stats, day):
                dct_day=dct_sell_stats.get(day)
                for key in dct_day.keys():
                    sum_GainUSD_week=sum_GainUSD_week+float(dct_day[key]["gain_USD"])
        stats_str= stats_str+"\nGain last 7 days $:"+float0f(sum_GainUSD_week)
        sum_GainUSD_month=0
        for x in range(0, 32):
            day=datetime.datetime.now()-datetime.timedelta(days=int(x))
            day=str(day.strftime("%Y-%m-%d"))
            if findkeys(dct_sell_stats, day):
                dct_day=dct_sell_stats.get(day)
                for key in dct_day.keys():
                    sum_GainUSD_month=sum_GainUSD_month+float(dct_day[key]["gain_USD"])
        stats_str= stats_str+"\nGain last 31 days $:"+float0f(sum_GainUSD_month)
    return stats_str
logger = logging.getLogger(__name__)

# Define a few command handlers. These usually take the two arguments bot and
# update. Error handlers also receive the raised TelegramError object in error.

def float8f(float8f_value):
    return format(float(float8f_value), '.8f')

def start(bot, update):
    """Send a message when the command /start is issued."""
    update.message.reply_text('Hi!')

def Detail_Status(bot, update):
    """Send a message when the command /start is issued."""
    update.message.reply_text('Hi!')

def menu(bot):
    """Send a message when the command /menu is issued."""
#    update.message.reply_text('menu activating!')
    menu_keyboard = [['Status', 'Stats'], ['StartAutotrade', 'StopAutotrade'], ['Kill', 'Panicsell'], ['/help']]
    menu_markup = ReplyKeyboardMarkup(menu_keyboard, one_time_keyboard=False, resize_keyboard=True)
    global my_telegram_id
    try:
        bot.send_message(my_telegram_id, text='Select button:', reply_markup=menu_markup)
    except:
        print "Timeout telegram"

def build_menu(buttons,
               n_cols,
               header_buttons=None,
               footer_buttons=None):
    menu = [buttons[i:i + n_cols] for i in range(0, len(buttons), n_cols)]
    if header_buttons:
        menu.insert(0, header_buttons)
    if footer_buttons:
        menu.append(footer_buttons)
#    print menu
    return menu

def button(bot, update):
    query = update.callback_query
    print query.data
    str_msg=""
    if "panicsell:" in query.data:
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename and query.data.replace("panicsell:","") in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                dct_FILE['panicsell']=1
                save_obj(dct_FILE, dct_FILE.get("filename"))
                str_msg=str_msg+"\n"+"Panic sell sent:"+query.data.replace("panicsell:","")
        if str_msg<>"":
            bot.editMessageText(text=str_msg,
                                chat_id=query.message.chat_id,
                                message_id=query.message.message_id)
    elif "kill:" in query.data:
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and query.data.replace("kill:","") in filename:
                print(api_path+"trades/"+filename)
                os.rename(api_path+"trades/"+filename, api_path+"old/"+filename)
                str_msg=str_msg+"\n"+"Kill ok:"+filename
        if "signals/" in query.data.replace("kill:",""):
            filepath=query.data.replace("kill:","")
            print(filepath)
            os.rename(filepath, filepath.replace("signals/","old/"))
            str_msg=str_msg+"\n"+"Kill ok: "+filepath.replace(api_path+"signals/","")
        if str_msg<>"":
            bot.editMessageText(text=str_msg,
                                    chat_id=query.message.chat_id,
                                    message_id=query.message.message_id)
    elif "signals/" in query.data:
        for filename in os.listdir(api_path+"signals/"):
            if query.data in api_path+"signals/"+filename:
                print(api_path+"signals/"+filename)
                text_file = open(api_path+"signals/"+filename, "r")
                str_msg=text_file.read()
                text_file.close()
    else:
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename and query.data in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                if dct_FILE.has_key('order_BUY_FILLED'):
                    percentage_gain_lost=float(dct_FILE['binance_price'])/float(dct_FILE['order_BUY_FILLED']['price'])*100-100
                    percentage_gain_lost=format(percentage_gain_lost, '.2f')
                    last_sl_stop=dct_FILE['SL']
                    if dct_FILE.has_key('order_T2_SL') or dct_FILE.has_key('order_T1_SL'): last_sl_stop=dct_FILE['last_SL_stopPrice']
                    status_dict="Buy price:   "+str(float8f(dct_FILE['order_BUY_FILLED']['price']))\
                        +"\n"+"Last price:  "+str(float8f(dct_FILE['binance_price']))\
                        +"\n"+"Last SL :     "+str(float8f(last_sl_stop))\
                        +"\n"+"Gain/Lost: "+str(percentage_gain_lost)+"%"\
                        +"\n"+"T1: "+str(float8f(dct_FILE['T1']))\
                        +"\n"+"T2: "+str(float8f(dct_FILE['T2']))\
                        +"\n"+"T3: "+str(float8f(dct_FILE['T3']))\
                        +"\nLevel: "+dct_FILE['last_order_level']
                    str_msg=str_msg+"\n"+filename+"\n"+str(status_dict)
                else:
                    str_msg=str_msg+"\n"+filename+"\n"+"Order not filled"
    if str_msg<>"":
        bot.editMessageText(text=str_msg,
                            chat_id=query.message.chat_id,
                            message_id=query.message.message_id)

def help(bot, update):
    """Send a message when the command /help is issued."""
    update.message.reply_text('Help!\nPause:5 Met en pause pour 5min\nStatus Donne le status de chaque trade\nstopautotrade or startautotrade: Disable or enable auto_trade in INI\nStats Donne les stats de vente\nKill:XLMBTC Stop la surveillance de la paire\nSignal... Met en fil d attente la position selon les valeurs\n')

def echo(bot, update):
    """Echo the user message."""
    print "BEGIN response"
    global my_telegram_id
    text_sent=update.message.text.lower()
    print text_sent
    printable = set(string.printable)
    text_sent=filter(lambda x: x in printable, text_sent)
    if "pause:" in text_sent:
        print "Create pause.txt"
        a_pause=text_sent.split("pause:")
        print a_pause[1]
        text_file = open("pause.txt", "w")
        f_time=datetime.datetime.now().replace(microsecond=0)+datetime.timedelta(minutes=int(a_pause[1]))
        text_file.write(str(f_time))
        text_file.close()
        update.message.reply_text("Pause until: "+str(f_time))
    elif text_sent=="stats":
        sell_stats_file=cwd+"/"+json_stats
        if not os.path.isfile(sell_stats_file):
            update.message.reply_text("Stats empty")
        else:
            update.message.reply_text(stats())
    elif text_sent=="stopautotrade":
            load_params.read("binance_api.ini")
            load_params.set('BINANCE_API','auto_trade',0)
            cfgfile = open("binance_api.ini",'w')
            load_params.write(cfgfile)
            cfgfile.close()
            update.message.reply_text("OK")
    elif text_sent=="startautotrade":
            load_params.read("binance_api.ini")
            load_params.set('BINANCE_API','auto_trade',1)
            cfgfile = open("binance_api.ini",'w')
            load_params.write(cfgfile)
            cfgfile.close()
            update.message.reply_text("OK")
    elif text_sent=="status":
#        print "status"
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+"signals/"):
            print(api_path+"signals/"+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data=api_path+"signals/"+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='All signals:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                executedDate_creation= dct_FILE['executedDate_creation']
                f_time=datetime.datetime.strptime(executedDate_creation.replace("_", " "), '%Y-%m-%d %H.%M.%S')
                diff_time=datetime.datetime.now().replace(microsecond=0)-f_time
#                print diff_time.days
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
#                print status_dict
                status_dict[dct_FILE.get("symbol")+"Days"]=str(diff_time.days)
                status_dict[dct_FILE.get("symbol")+"LL"]=dct_FILE['last_order_level'].replace("order_", "")
#                print status_dict
        if status_dict<>{}:
            for symbols in sorted(status_dict):
#                print symbols
                if not "Days" in symbols and not "LL" in symbols:
                    button_list.append(InlineKeyboardButton(symbols.replace("BTC", "")+":"+str(status_dict[symbols+"LL"])+":"+str(status_dict[symbols+"Days"])+"d", callback_data=symbols))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        list_of_files = glob.glob(api_path+"logs/*")
        latest_file = max(list_of_files, key=os.path.getctime)
        update.message.reply_text("Dernier log:"+time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime(latest_file))))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='All trades:', reply_markup=reply_markup)
    elif text_sent=="panicsell":
        print "panicsell"
        status_dict = {}
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
        button_list = []
        for symbols in sorted(status_dict):
            button_list.append(InlineKeyboardButton(hot+symbols, callback_data="panicsell:"+symbols))
        reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        bot.send_message(my_telegram_id, text='Which panicsell symbol(s):', reply_markup=reply_markup)
    elif text_sent=="kill":
        print "kill"
        status_dict = {}
        button_list = []
        reply_markup = ""
        for filename in os.listdir(api_path+"signals/"):
            print(api_path+"signals/"+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data="kill:"+api_path+"signals/"+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='Which kill signal:', reply_markup=reply_markup)
        for filename in os.listdir(api_path+"trades/"):
            if ".json" in filename and not ".log" in filename:
                print(api_path+"trades/"+filename)
                dct_FILE=load_obj(api_path+"trades/"+filename)
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
        button_list = []
        reply_markup = ""
        for symbols in sorted(status_dict):
            button_list.append(InlineKeyboardButton(croix+symbols, callback_data="kill:"+symbols))
        reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        if reply_markup <> "":
            bot.send_message(my_telegram_id, text='Which kill symbol(s):', reply_markup=reply_markup)
    elif "btc" in text_sent:
        print "signal"
        signal_dict = {}
        signal_dict['C'] = 'init'
        signal_dict['AC'] = 'init'
        signal_dict['T1'] = 'init'
        signal_dict['T2'] = 'init'
        signal_dict['T3'] = 'init'
        signal_dict['SL'] = 'init'
        signal_dict['USD'] = 'init'
#        signal_dict['BAD'] = 'init'
        lines=text_sent
        lines=lines.splitlines()
        for line in lines:
            line=line.replace(" ", "")
            line=line.replace("/", "")
            line=line.replace("#", ":")
            line=line.replace("$", "")
            line=line.replace("coin:", "")
#            print(line)
#Crypto Signalist Pro
            if "btc" in line:
                signal_dict['C'] = line.upper()
                if signal_dict['C'].find("("):
                    a_symbol=signal_dict['C']
                    a_symbol=a_symbol.split('(', 1)[0]
                    signal_dict['C'] = a_symbol
                if signal_dict['C'].find("-"):
                    a_symbol=signal_dict['C']
                    a_symbol=a_symbol.split('-', 1)[0]
                    signal_dict['C'] = a_symbol
            if "usd" in line:
                a_usd=line.split("usd:")
                signal_dict['USD'] = a_usd[1]
#            if "buy:" in line:
#                a_buy=line.split("buy:")
#                signal_dict['AC'] = str(float(a_buy[1]))
            if "sell:" in line:
                a_sell=line.split("sell:")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = float8f(float(a_sell[0]))
                signal_dict['T2'] = float8f(float(a_sell[1]))
                signal_dict['T3'] = float8f(float(a_sell[2]))
            if "t1:" in line and "t2:" in line and "t3:" in line :
                a_t1t2t3=line.replace("t1","")
                a_t1t2t3=a_t1t2t3.replace("t2","")
                a_t1t2t3=a_t1t2t3.replace("t3","")
                a_t1t2t3=a_t1t2t3.split(":")
                signal_dict['T1'] = float8f(float(a_t1t2t3[1]))
                signal_dict['T2'] = float8f(float(a_t1t2t3[2]))
                signal_dict['T3'] = float8f(float(a_t1t2t3[3]))
            if "stop:" in line:
                a_stop=line.split("stop:")
                signal_dict['SL'] = float8f(float(a_stop[1]))
#Signal Profits
            if "buy:" in line:
                a_buy=line
                a_buy=a_buy.split("buy:")
                a_buy=a_buy[1]
                a_buy=a_buy.split('-', 1)[0]
                signal_dict['AC'] = float8f(float(a_buy))
            if "buyzone:" in line:
                a_buy=line
                a_buy=a_buy.split("buyzone:")
                a_buy=a_buy[1].split('-', 1)[0]
                signal_dict['AC'] = float8f(float(a_buy))
            if "buybelow:" in line:
                a_buy=line
                a_buy=a_buy.split("buybelow:")
                a_buy=a_buy[1].split('-', 1)[0]
                signal_dict['AC'] = float8f(float(a_buy))
            if "buybeloworcloseto:" in line:
                a_buy=line
                a_buy=a_buy.split("buybeloworcloseto:")
                a_buy=a_buy[1].split('-', 1)[0]
                signal_dict['AC'] = float8f(float(a_buy))
            if "entryzone:" in line:
                a_buy=line
                a_buy=a_buy.split("entryzone:")
                a_buy=a_buy[1].split('-', 1)[0]
                signal_dict['AC'] = float8f(float(a_buy))
            if "target1:" in line:
                a_t1=line
                a_t1=a_t1.split("target1:")
                a_t1=a_t1[1].split('(', 1)[0]
                signal_dict['T1'] = float8f(float(a_t1))
            if "target2:" in line:
                a_t2=line
                a_t2=a_t2.split("target2:")
                a_t2=a_t2[1].split('(', 1)[0]
                signal_dict['T2'] = float8f(float(a_t2))
            if "target3:" in line:
                a_t3=line
                a_t3=a_t3.split("target3:")
                a_t3=a_t3[1].split('(', 1)[0]
            if "t1:" in line and signal_dict['T1']=="init":
                a_t1=line
                a_t1=a_t1.split("t1:")
                a_t1=a_t1[1].split('(', 1)[0]
                signal_dict['T1'] = float8f(float(a_t1))
            if "t2:" in line and signal_dict['T2']=="init":
                a_t2=line
                a_t2=a_t2.split("t2:")
                a_t2=a_t2[1].split('(', 1)[0]
                signal_dict['T2'] = float8f(float(a_t2))
            if "t3:" in line and signal_dict['T3']=="init":
                a_t3=line
                a_t3=a_t3.split("t3:")
                a_t3=a_t3[1].split('(', 1)[0]
                signal_dict['T3'] = float8f(float(a_t3))
            if "stoploss:" in line:
                a_stop=line
                a_stop=a_stop.split("stoploss:")
                signal_dict['SL'] = a_stop[1]
                if signal_dict['SL'].find("("):
                    a_sl=signal_dict['SL']
                    a_sl=a_sl.split('(', 1)[0]
                    signal_dict['SL'] = float8f(float(a_sl))
            if "stoplimit:" in line:
                a_sl=line
                a_sl=a_sl.split("stoplimit:")
                signal_dict['SL'] = a_sl[1]
                if signal_dict['SL'].find("("):
                    a_sl=signal_dict['SL']
                    a_sl=a_sl.split('(', 1)[0]
                    signal_dict['SL'] = float8f(float(a_sl))
        key_not_find=0
        str_file="[TRADE]\n"
        if signal_dict['USD']=="init": signal_dict['USD'] = ConfigSectionMap("BINANCE_API", load_params)['usd_to_bet']
        for key, value in sorted(signal_dict.items()):
            if value == 'init':
                update.message.reply_text("Valeur non trouvee:"+key)
                key_not_find=1
            else:
                str_file=str_file+key.upper()+":"+value.strip()+"\n"

        if key_not_find<>1:
            if not float(signal_dict['SL'])<=float(signal_dict['AC'])<=float(signal_dict['T1'])<=float(signal_dict['T2'])<=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers")
            else:
                text_file = open(api_path+"/signals/"+signal_dict['C'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S"), "w")
                text_file.write(str_file)
                text_file.close()
                update.message.reply_text("Signal resolu:\n"+str_file)
        else:
            update.message.reply_text("Signal non resolu, format:\nXLMBTC\nBuy:0.01\nSell: 0.02-0.03-0.04\nStop:0.005\nUSD:100\nOu format:\nXLMBTC\nBuy:0.01\nT1:0.02\nT2:0.03\nT3:0.04\nStop Loss:0.005\nUSD:100")
#            print str_file
    else:
        update.message.reply_text("I dont understand")
#    menu(bot)
    print "END response"
    
def load_obj(name ):
#    with open(name, 'rb') as f:
#        debugapp(str(sys._getframe().f_code.co_name)+"|"+"Ouvre l objet depuis: "+name,debugapp_DebugLevel="DEBUG", debugapp_logger=logger)
#        return pickle.load(f)
    with open(name) as json_data:
        dct_load_obj = json.load(json_data)
        json_data.close()
        return dct_load_obj

def save_obj(obj, name ):
    if not ".json" in name and not ".laststate" in name:
#        with open(name, 'wb') as f:
#        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)
            pass
    else:
        save_obj_out_file = open(name,"w")
        json.dump(obj,save_obj_out_file, indent=4, sort_keys=True)                                    
        save_obj_out_file.close()

def error(bot, update, error):
    """Log Errors caused by Updates."""
    logger.warning('Update "%s" caused error "%s"', update, error)

def main():
    """Start the bot."""
    # Create the EventHandler and pass it your bot's token.
    my_telegram_bot_token = ConfigSectionMap("BINANCE_API", load_params)['my_telegram_bot_token']
    global updater
    updater = Updater(my_telegram_bot_token)
    bot = telegram.Bot(my_telegram_bot_token)

    menu(bot)

    # Get the dispatcher to register handlers
    dp = updater.dispatcher

    # on different commands - answer in Telegram
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("menu", menu))
    dp.add_handler(CommandHandler("help", help))

    # on noncommand i.e message - echo the message on Telegram
    dp.add_handler(MessageHandler(Filters.text, echo))
    dp.add_handler(CallbackQueryHandler(button))

    # log all errors
    dp.add_error_handler(error)

    # Start the Bot
    updater.start_polling()
    
    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()

print "Starting Bot"
if __name__ == '__main__':
    main()
