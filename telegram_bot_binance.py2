#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Press Ctrl-C on the command line or send a signal to the process to stop the
bot.
"""

from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackQueryHandler
import telegram
from telegram import ReplyKeyboardMarkup,  InlineKeyboardMarkup,  InlineKeyboardButton
import logging
import os
import datetime
import time
import string,  re
import json
import glob
import ccxt  # noqa: E402
json_stats="sell_stats.json"
json_ini="api4.json"

binance_trades_path="trades/"
binance_signals_path="signals/"
bitmex_signals_path="bitmex_signals/"
bitmex_trades_path="bitmex_trades/"
old_path="old/"
hodl_path="hodl/"

cwd = os.getcwd()
api_path=cwd+"/"
# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
level=logging.INFO)

hot = u'\U0001F525'             # Code: 904
clouds = u'\U00002601'          # Code: 802-803-804 clouds general
croix = u'\U0000274C'          # Code: 802-803-804 clouds general
interrogation = u'\U00002753'          # Code: 802-803-804 clouds general

signal_dict = {}

def load_obj(name ):
    with open(name) as json_data:
        dct_load_obj = json.load(json_data)
        json_data.close()
        return dct_load_obj
        
dct_INI_JSON=load_obj(json_ini)
bitmex = ccxt.bitmex()
binance = ccxt.binance()
binance_markets=binance.fetch_markets()
def init_dict():
    dictA = {}
    dictA['C'] = 'init'
    dictA['AC'] = 'init'
    dictA['T1'] = 'init'
    dictA['T2'] = 'init'
    dictA['T3'] = 'init'
    dictA['SL'] = 'init'
    dictA['USD'] = 'init'
    dictA['CHNL'] = ""
    dictA['POS'] = 'init'
    return dictA
    
def percentage_calc(percentage_calc_number, percentage_calc_percent):
    percentage_calc_result = float(percentage_calc_number)+float(percentage_calc_number)/100*float(percentage_calc_percent)
    return percentage_calc_result

def clean_text(text):
    text=text.replace(" ", "")
    text=text.replace("|", "-")
    text=text.replace("/", "")
    text=text.replace("#", ":")
    text=text.replace("*", "")
    text=text.replace("@", ":")
    text=text.replace("--->", "")
    text=text.replace("$", "")
    text=text.replace("~", ":")
    text=text.replace("binance", "")
    text=text.replace("bitmex", "")
    return text

def save_obj(obj, name ):
    save_obj_out_file = open(name,"w")
    json.dump(obj,save_obj_out_file, indent=4, sort_keys=True)                                    
    save_obj_out_file.close()

def extract_numbers(extract_numbers_str, **kwargs):
    if extract_numbers_str[:1]=="-":extract_numbers_str=extract_numbers_str[1:]
#    print extract_numbers_str
    if "-" in extract_numbers_str:
        extract_numbers_str_array=extract_numbers_str.split("-")
#        print "extract_numbers_str_array:"+str(extract_numbers_str_array)
        if len(extract_numbers_str_array)>=2:
            if "%" in extract_numbers_str_array[1]:
                extract_numbers_str_array_cell=extract_numbers_str_array[0]
            else:
                extract_numbers_str_array_cell=extract_numbers_str_array[1]
        elif len(extract_numbers_str_array)==1:
            extract_numbers_str_array_cell=extract_numbers_str_array[0]
    else:
        extract_numbers_str_array_cell=extract_numbers_str
#    print "extract_numbers_str_array_cell:"+str(extract_numbers_str_array_cell)
    extract_numbers_array=re.findall(r'\d+',extract_numbers_str_array_cell)
#    print "extract_numbers_array:"+str(extract_numbers_array)
    global signal_dict
    if extract_numbers_array:
#        print "extract_numbers"+str(extract_numbers_array)
        if extract_numbers_array[0]=="0":
            return float8f(str(extract_numbers_array[0]+"."+extract_numbers_array[1]))
        elif extract_numbers_array[0]=="0":
            return float8f(str(extract_numbers_array[0]+"."+extract_numbers_array[1]))
        elif "USD" in signal_dict['C']:
            return str(extract_numbers_array[0])
        elif kwargs.get("satoshi_extract_numbers")==1:
            len_tickSize=get_tickSize(signal_dict['C'])
            len_satoshi=len_tickSize-len(str(extract_numbers_array[0]))
            xbt_value=""
            for x in range(1, len_satoshi):
                xbt_value=xbt_value+"0"
            return "0."+xbt_value+str(extract_numbers_array[0])
        else:
            return "init"
    else:
        return "init"

def get_price_type(get_price_type_str, get_price_type_valeurs, **kwargs):
    for valeur in get_price_type_valeurs:
        if valeur in get_price_type_str:
            return extract_numbers(get_price_type_str.replace(valeur, ""), satoshi_extract_numbers=kwargs.get("satoshi"))
    return "init"
    
def get_tickSize(get_tickSize_symbol):
    bitmex_markets=bitmex.fetch_markets()
    actual_market=None
    for market in bitmex_markets:
        if market['id']==get_tickSize_symbol:
            get_tickSize_symbol=market['symbol']
            actual_market=market
            break
        elif market['symbol']==get_tickSize_symbol:
            actual_market=market
            break
    if actual_market<>None:
        pos=str(float16f(actual_market['info']['tickSize'])).find("1")
    elif actual_market==None:
        binance_markets=binance.fetch_markets()
        actual_market=None
        for market in binance_markets:
            if market['id']==get_tickSize_symbol:
                get_tickSize_symbol=market['symbol']
                actual_market=market
                break
            elif market['symbol']==get_tickSize_symbol:
                actual_market=market
                break
        pos=str(float16f(actual_market['info']['filters'][0]['tickSize'])).find("1")
    return pos
    
def findkeys(d, findkeys_str):
    for key in d.keys():
        if findkeys_str in key:
            return 1
    return 0
    
def float0f(float0f_value):
    return format(float(float0f_value), '.0f')

def stats():
    sell_stats_file=cwd+json_stats
    stats_str=""
    with open(sell_stats_file) as json_data:
        dct_sell_stats = json.load(json_data)
        json_data.close()
        sum_GainUSD_today=0
        today=datetime.datetime.now().strftime("%Y-%m-%d")
        if findkeys(dct_sell_stats, today):
            dct_today=dct_sell_stats.get(today)
            for key in dct_today.keys():
                sum_GainUSD_today=sum_GainUSD_today+float(dct_today[key]["gain_USD"])
        stats_str= "Gain today $:"+float0f(sum_GainUSD_today)
        sum_GainUSD_week=0
        for x in range(0, 8):
            day=datetime.datetime.now()-datetime.timedelta(days=int(x))
            day=str(day.strftime("%Y-%m-%d"))
            if findkeys(dct_sell_stats, day):
                dct_day=dct_sell_stats.get(day)
                for key in dct_day.keys():
                    sum_GainUSD_week=sum_GainUSD_week+float(dct_day[key]["gain_USD"])
        stats_str= stats_str+"\nGain last 7 days $:"+float0f(sum_GainUSD_week)
        sum_GainUSD_month=0
        for x in range(0, 32):
            day=datetime.datetime.now()-datetime.timedelta(days=int(x))
            day=str(day.strftime("%Y-%m-%d"))
            if findkeys(dct_sell_stats, day):
                dct_day=dct_sell_stats.get(day)
                for key in dct_day.keys():
                    sum_GainUSD_month=sum_GainUSD_month+float(dct_day[key]["gain_USD"])
        stats_str= stats_str+"\nGain last 31 days $:"+float0f(sum_GainUSD_month)
    return stats_str
logger = logging.getLogger(__name__)

def float8f(float8f_value):
    return format(float(float8f_value), '.8f')

def float16f(float16f_value):
    return format(float(float16f_value), '.16f')

def start(bot, update):
    """Send a message when the command /start is issued."""
    update.message.reply_text('Hi!')

def Detail_Status(bot, update):
    """Send a message when the command /start is issued."""
    update.message.reply_text('Hi!')

def menu(bot):
    """Send a message when the command /menu is issued."""
    menu_keyboard = [['Status', 'Stats'], ['StartAutotrade_binance', 'StopAutotrade_binance'], ['StartAutotrade_bitmex', 'StopAutotrade_bitmex'], ['Kill', 'Panicsell'], ['/help']]
    menu_markup = ReplyKeyboardMarkup(menu_keyboard, one_time_keyboard=False, resize_keyboard=True)
    try:
        bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='Select button:', reply_markup=menu_markup)
    except:
        print "Timeout telegram"

def build_menu(buttons,
               n_cols,
               header_buttons=None,
               footer_buttons=None):
    menu = [buttons[i:i + n_cols] for i in range(0, len(buttons), n_cols)]
    if header_buttons:
        menu.insert(0, header_buttons)
    if footer_buttons:
        menu.append(footer_buttons)
    return menu

def button(bot, update):
    query = update.callback_query
    print query.data
    str_msg=""
    if "panicsell:" in query.data:
        for filename in os.listdir(api_path+binance_trades_path):
            if ".json" in filename and not ".log" in filename and query.data.replace("panicsell:","") in filename:
                print(api_path+binance_trades_path+filename)
                dct_FILE=load_obj(api_path+binance_trades_path+filename)
                dct_FILE['panicsell']=1
                save_obj(dct_FILE, dct_FILE.get("filename"))
                str_msg=str_msg+"\n"+"Panic sell sent:"+query.data.replace("panicsell:","")
        if str_msg<>"":
            bot.editMessageText(text=str_msg,
                                chat_id=query.message.chat_id,
                                message_id=query.message.message_id)
    elif "kill:" in query.data:
        for filename in os.listdir(api_path+binance_trades_path):
            if ".json" in filename and query.data.replace("kill:","") in filename:
                print(api_path+binance_trades_path+filename)
                os.rename(api_path+binance_trades_path+filename, api_path+old_path+filename)
                str_msg=str_msg+"\n"+"Kill ok:"+filename
        for filename in os.listdir(api_path+bitmex_trades_path):
            if ".json" in filename and query.data.replace("kill:","").replace("/", "") in filename:
                print(api_path+bitmex_trades_path+filename)
                os.rename(api_path+bitmex_trades_path+filename, api_path+old_path+filename)
                str_msg=str_msg+"\n"+"Kill ok:"+filename
        if "/signals/" in query.data.replace("kill:",""):
            filepath=query.data.replace("kill:","")
            print(filepath)
            os.rename(filepath, filepath.replace(binance_signals_path,old_path))
            str_msg=str_msg+"\n"+"Kill ok: "+filepath.replace(api_path+binance_signals_path,"")
        if bitmex_signals_path in query.data.replace("kill:",""):
            filepath=query.data.replace("kill:","")
            print(filepath)
            os.rename(filepath, filepath.replace(bitmex_signals_path,old_path))
            str_msg=str_msg+"\n"+"Kill ok: "+filepath.replace(api_path+bitmex_signals_path,"")
        if str_msg<>"":
            bot.editMessageText(text=str_msg,
                                    chat_id=query.message.chat_id,
                                    message_id=query.message.message_id)
    elif binance_signals_path in query.data:
        for filename in os.listdir(api_path+binance_signals_path):
            if query.data in api_path+binance_signals_path+filename:
                print(api_path+binance_signals_path+filename)
                text_file = open(api_path+binance_signals_path+filename, "r")
                str_msg=text_file.read()
                text_file.close()

    elif bitmex_signals_path in query.data:
        for filename in os.listdir(api_path+bitmex_signals_path):
            if query.data in api_path+bitmex_signals_path+filename:
                print(api_path+bitmex_signals_path+filename)
                text_file = open(api_path+bitmex_signals_path+filename, "r")
                str_msg=text_file.read()
                text_file.close()

    elif ".bitmex_trades" in query.data:
        print(api_path+bitmex_trades_path)
        for filename in os.listdir(api_path+bitmex_trades_path):
            if ".json" in filename and not ".log" in filename and query.data.replace(".bitmex_trades", "").replace("/", "") in filename:
                print(api_path+bitmex_trades_path+filename)
                dct_FILE=load_obj(api_path+bitmex_trades_path+filename)
                if dct_FILE.has_key('order_BUY_FILLED'):
                    percentage_gain_lost=float(dct_FILE['float_bitmex_price'])/float(dct_FILE['order_BUY_FILLED']['price'])*100-100
                    if dct_FILE['POS']=="short":percentage_gain_lost=-percentage_gain_lost
                    percentage_gain_lost=format(percentage_gain_lost, '.2f')
                    last_sl_stop=dct_FILE['SL']
                    if dct_FILE.has_key('order_T2_SL') or dct_FILE.has_key('order_T1_SL'): last_sl_stop=dct_FILE['last_SL_stopPrice']
                    status_dict="Buy price:   "+str(float8f(dct_FILE['order_BUY_FILLED']['info']['avgPx']))\
                        +"\n"+"Last price:  "+str(float8f(dct_FILE['float_bitmex_price']))\
                        +"\n"+"Last SL :     "+str(float8f(last_sl_stop))\
                        +"\n"+"Gain/Lost: "+str(percentage_gain_lost)+"%"\
                        +"\n"+"POS: "+str(dct_FILE['POS'])\
                        +"\n"+"T1: "+str(float8f(dct_FILE['T1']))\
                        +"\n"+"T2: "+str(float8f(dct_FILE['T2']))\
                        +"\n"+"T3: "+str(float8f(dct_FILE['T3']))\
                        +"\nLevel: "+dct_FILE['last_order_level']
                    str_msg=str_msg+"\n"+filename+"\n"+str(status_dict)
                    print "1"
                    print str_msg
                else:
                    str_msg=str_msg+"\n"+filename+"\n"+"Order not filled"
    else:
        for filename in os.listdir(api_path+binance_trades_path):
            if ".json" in filename and not ".log" in filename and query.data in filename:
                print(api_path+binance_trades_path+filename)
                dct_FILE=load_obj(api_path+binance_trades_path+filename)
                if dct_FILE.has_key('order_BUY_FILLED'):
                    percentage_gain_lost=float(dct_FILE['binance_price'])/float(dct_FILE['order_BUY_FILLED']['price'])*100-100
                    percentage_gain_lost=format(percentage_gain_lost, '.2f')
                    last_sl_stop=dct_FILE['SL']
                    if dct_FILE.has_key('order_T2_SL') or dct_FILE.has_key('order_T1_SL'): last_sl_stop=dct_FILE['last_SL_stopPrice']
                    status_dict="Buy price:   "+str(float8f(dct_FILE['order_BUY_FILLED']['price']))\
                        +"\n"+"Last price:  "+str(float8f(dct_FILE['binance_price']))\
                        +"\n"+"Last SL :     "+str(float8f(last_sl_stop))\
                        +"\n"+"Gain/Lost: "+str(percentage_gain_lost)+"%"\
                        +"\n"+"T1: "+str(float8f(dct_FILE['T1']))\
                        +"\n"+"T2: "+str(float8f(dct_FILE['T2']))\
                        +"\n"+"T3: "+str(float8f(dct_FILE['T3']))\
                        +"\nLevel: "+dct_FILE['last_order_level']
                    str_msg=str_msg+"\n"+filename+"\n"+str(status_dict)
                else:
                    str_msg=str_msg+"\n"+filename+"\n"+"Order not filled"
    if str_msg<>"":
        bot.editMessageText(text=str_msg,
                            chat_id=query.message.chat_id,
                            message_id=query.message.message_id)

def help(bot, update):
    """Send a message when the command /help is issued."""
    update.message.reply_text('Help!\nPause:5 Met en pause pour 5min\nStatus Donne le status de chaque trade\nstopautotrade or startautotrade: Disable or enable auto_trade in INI\nStats Donne les stats de vente\nKill:XLMBTC Stop la surveillance de la paire\nSignal... Met en fil d attente la position selon les valeurs\n')

def echo(bot, update):
    """Echo the user message."""
    print "BEGIN response"
    global signal_dict
    global dct_INI_JSON
    dct_INI_JSON=load_obj(json_ini)
#    print str(update.message)
    text_sent=update.message.text.lower()
    printable = set(string.printable)
    text_sent=filter(lambda x: x in printable, text_sent)
    channel=""
    if "pause:" in text_sent:
        print "Create pause.txt"
        a_pause=text_sent.split("pause:")
        print a_pause[1]
        text_file = open("pause.txt", "w")
        f_time=datetime.datetime.now().replace(microsecond=0)+datetime.timedelta(minutes=int(a_pause[1]))
        text_file.write(str(f_time))
        text_file.close()
        update.message.reply_text("Pause until: "+str(f_time))
    elif text_sent=="stats":
        sell_stats_file=cwd+json_stats
        if not os.path.isfile(sell_stats_file):
            update.message.reply_text("Stats empty")
        else:
            update.message.reply_text(stats())
    elif text_sent[:5]=="hodl:":
        print "hodl"
        hodl_dict = {}
        hodl_dict['symbol'] = text_sent.replace("hodl:", "")
        hodl_dict['symbol'] = hodl_dict['symbol'].upper()
        hodl_dict['SL'] = 'init'
        hodl_dict['last_orderId'] = 'init'
        hodl_dict['max_price'] = 'init'
        hodl_dict['last_order_level'] = 'init'
        hodl_dict['executedQty_creation'] = 0
        hodl_dict['executedQty_vendu'] = 0
        hodl_dict['filename'] = 'init'
        hodl_dict['dictToBeFilled'] = {}
        hodl_dict['float_percentage_max_hodl_sl']=dct_INI_JSON['float_percentage_max_hodl_sl']
        hodl_dict['float_percentage_sl_upside']=dct_INI_JSON['float_percentage_sl_upside']
        hodl_dict['float_percentage_control_balance']=dct_INI_JSON['float_percentage_control_balance']
        hodl_dict['CHNL'] = channel

        print("creation hodl file:"+api_path+hodl_path+hodl_dict['symbol'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S")+".json")
        save_obj(hodl_dict, api_path+hodl_path+hodl_dict['symbol'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S")+".json")
        update.message.reply_text("Hodl launched: "+hodl_dict['symbol'])

    elif text_sent=="stopautotrade_binance":
            dct_INI_JSON=load_obj(json_ini)
            dct_INI_JSON['bool_auto_trade_binance']=False
            save_obj(dct_INI_JSON, json_ini)
            update.message.reply_text("OK")
    elif text_sent=="startautotrade_binance":
            dct_INI_JSON=load_obj(json_ini)
            dct_INI_JSON['bool_auto_trade_binance']=True
            save_obj(dct_INI_JSON, json_ini)
            update.message.reply_text("OK")
    elif text_sent=="stopautotrade_bitmex":
            dct_INI_JSON=load_obj(json_ini)
            dct_INI_JSON['bool_auto_trade_bitmex']=False
            save_obj(dct_INI_JSON, json_ini)
            update.message.reply_text("OK")
    elif text_sent=="startautotrade_bitmex":
            dct_INI_JSON=load_obj(json_ini)
            dct_INI_JSON['bool_auto_trade_bitmex']=True
            save_obj(dct_INI_JSON, json_ini)
            update.message.reply_text("OK")
    elif text_sent=="status":
#        print "status"
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+binance_signals_path):
            print(api_path+binance_signals_path+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data=api_path+binance_signals_path+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='All binance signals:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+bitmex_signals_path):
            print(api_path+bitmex_signals_path+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data=api_path+bitmex_signals_path+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='All bitmex signals:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+binance_trades_path):
            if ".json" in filename and not ".log" in filename:
                print(api_path+binance_trades_path+filename)
                dct_FILE=load_obj(api_path+binance_trades_path+filename)
                executedDate_creation= dct_FILE['executedDate_creation']
                f_time=datetime.datetime.strptime(executedDate_creation.replace("_", " "), '%Y-%m-%d %H.%M.%S')
                diff_time=datetime.datetime.now().replace(microsecond=0)-f_time
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
                status_dict[dct_FILE.get("symbol")+"Days"]=str(diff_time.days)
                status_dict[dct_FILE.get("symbol")+"LL"]=dct_FILE['last_order_level'].replace("order_", "")
        if status_dict<>{}:
            for symbols in sorted(status_dict):
                if not "Days" in symbols and not "LL" in symbols:
                    button_list.append(InlineKeyboardButton(symbols.replace("BTC", "")+":"+str(status_dict[symbols+"LL"])+":"+str(status_dict[symbols+"Days"])+"d", callback_data=symbols))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        list_of_files = glob.glob(api_path+"logs/*")
        latest_file = max(list_of_files, key=os.path.getctime)
        dct_INI_JSON=load_obj(json_ini)
        if reply_markup <> "":
            bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='All binance trades:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup=""
        for filename in os.listdir(api_path+bitmex_trades_path):
            if ".json" in filename and not ".log" in filename:
                print(api_path+bitmex_trades_path+filename)
                dct_FILE=load_obj(api_path+bitmex_trades_path+filename)
                executedDate_creation= dct_FILE['executedDate_creation']
                f_time=datetime.datetime.strptime(executedDate_creation.replace("_", " "), '%Y-%m-%d %H.%M.%S')
                diff_time=datetime.datetime.now().replace(microsecond=0)-f_time
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['float_bitmex_price']))+"\n"+dct_FILE['last_order_level']
                status_dict[dct_FILE.get("symbol")+"Days"]=str(diff_time.days)
                status_dict[dct_FILE.get("symbol")+"LL"]=dct_FILE['last_order_level'].replace("order_", "")
        if status_dict<>{}:
            for symbols in sorted(status_dict):
                if not "Days" in symbols and not "LL" in symbols:
                    button_list.append(InlineKeyboardButton(symbols+":"+str(status_dict[symbols+"LL"])+":"+str(status_dict[symbols+"Days"])+"d", callback_data=symbols+".bitmex_trades"))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        list_of_files_bitmex = glob.glob(api_path+"bitmex_logs/*")
        latest_file_bitmex = max(list_of_files_bitmex, key=os.path.getctime)
        list_of_files = glob.glob(api_path+"logs/*")
        latest_file = max(list_of_files, key=os.path.getctime)
        dct_INI_JSON=load_obj(json_ini)
        if reply_markup <> "":
            bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='All bitmex trades:', reply_markup=reply_markup)
        update.message.reply_text("Last log binance:"+time.strftime('%y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime(latest_file)))\
        +"\n"+"Last log bitmex:"+time.strftime('%y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime(latest_file_bitmex)))\
        +"\n"+"Last error:"+time.strftime('%y-%m-%d %H:%M:%S', time.localtime(os.path.getmtime("whatchdog_error.log")))\
        +"\nAutotrade binance:"+str(dct_INI_JSON['bool_auto_trade_binance'])\
        +"\nAutotrade bitmex:"+str(dct_INI_JSON['bool_auto_trade_bitmex']))
    elif text_sent=="panicsell":
        print "panicsell"
        status_dict = {}
        for filename in os.listdir(api_path+binance_trades_path):
            if ".json" in filename and not ".log" in filename:
                print(api_path+binance_trades_path+filename)
                dct_FILE=load_obj(api_path+binance_trades_path+filename)
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
        button_list = []
        for symbols in sorted(status_dict):
            button_list.append(InlineKeyboardButton(hot+symbols, callback_data="panicsell:"+symbols))
        reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='Which panicsell trades:', reply_markup=reply_markup)
    elif text_sent=="kill":
        print "kill"
        status_dict = {}
        button_list = []
        reply_markup = ""
        status_dict = {}
        button_list = []
        reply_markup = ""
#        print(api_path+bitmex_signals_path.replace("/", ""))
        for filename in os.listdir(api_path+bitmex_signals_path):
            print(api_path+bitmex_signals_path+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data="kill:"+api_path+bitmex_signals_path+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='Which kill bitmex signals:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup = ""
        for filename in os.listdir(api_path+binance_signals_path):
            print(api_path+binance_signals_path+filename)
            button_list.append(InlineKeyboardButton(filename, callback_data="kill:"+api_path+binance_signals_path+filename))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=1))
        if reply_markup <> "":
            bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='Which kill binance signals:', reply_markup=reply_markup)
        status_dict = {}
        button_list = []
        reply_markup = ""
        for filename in os.listdir(api_path+binance_trades_path):
            if ".json" in filename and not ".log" in filename:
                print(api_path+binance_trades_path+filename)
                dct_FILE=load_obj(api_path+binance_trades_path+filename)
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['binance_price']))+"\n"+dct_FILE['last_order_level']
        button_list = []
        reply_markup = ""
        for symbols in sorted(status_dict):
            button_list.append(InlineKeyboardButton(croix+symbols, callback_data="kill:"+symbols))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        if reply_markup <> "":
            bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='Which kill binance trades:', reply_markup=reply_markup)

        status_dict = {}
        button_list = []
        reply_markup = ""
        for filename in os.listdir(api_path+bitmex_trades_path):
            if ".json" in filename and not ".log" in filename:
                print(api_path+bitmex_trades_path+filename)
                dct_FILE=load_obj(api_path+bitmex_trades_path+filename)
                status_dict[dct_FILE.get("symbol")]=":Last price:"+str(float8f(dct_FILE['float_bitmex_price']))+"\n"+dct_FILE['last_order_level']
        button_list = []
        reply_markup = ""
        for symbols in sorted(status_dict):
            button_list.append(InlineKeyboardButton(croix+symbols, callback_data="kill:"+symbols))
            reply_markup = InlineKeyboardMarkup(build_menu(button_list, n_cols=3))
        if reply_markup <> "":
            bot.send_message(dct_INI_JSON['int_my_telegram_id'], text='Which kill bitmex trades:', reply_markup=reply_markup)

    elif "PeerChannel(channel_id=1229891129)".lower() in text_sent\
    or "PeerChannel(channel_id=1132337691)".lower() in text_sent\
    or "PeerChannel(channel_id=1114421815)".lower() in text_sent\
    or "PeerChannel(channel_id=1317593000)".lower() in text_sent\
    or "PeerChannel(channel_id=1398284234)".lower() in text_sent\
    or "PeerChannel(channel_id=1322719136XX)".lower() in text_sent\
    or "PeerChannel(channel_id=1133918305)".lower() in text_sent\
    or "Test_kall".lower() in text_sent\
    or "PeerUser(user_id=677414303)".lower() in text_sent:
        print "signal"
        symbol_dict_binance=load_obj("binance_prices.json")
        symbol_dict_bitmex=load_obj("bitmex_contracts.json")
        signal_dict = init_dict()
        lines = clean_text(text_sent)
        lines=lines.splitlines()
        for line in lines:
            print line
            if "PeerChannel(channel_id=".lower() in line or "PeerUser(user_id=".lower() in line:
                signal_dict['CHNL'] = line.replace("chnl:", "")
            satoshi_signal=1
            if line.upper()+"BTC" in symbol_dict_binance and signal_dict['C']=="init":
                signal_dict['C'] = line.upper()+"BTC"
            if "coin:" in line and signal_dict['C']=="init":
                a_coin=line.split("coin:")
                if a_coin[1].upper()+"USD" in symbol_dict_bitmex or a_coin[1].upper()=='XBT' or a_coin[1].upper()=='ETH':
                    signal_dict['C'] = a_coin[1].upper()+"USD"
                elif a_coin[1].upper()+"Z18" in symbol_dict_bitmex:
                    signal_dict['C'] = a_coin[1].upper()+"Z18"
                else:
                    signal_dict['C'] = a_coin[1].upper()+"BTC"
            if line.replace(":", "").upper()+"BTC" in symbol_dict_binance  and signal_dict['C']=="init":
                signal_dict['C'] = line.replace(":", "").upper()+"BTC"
            if line.upper() in symbol_dict_binance  and signal_dict['C']=="init":
                signal_dict['C'] = line.upper()
            if "USD" in signal_dict['C'] or signal_dict['C']=="XBTZ18":
                satoshi_signal=0
            if "tcalongsignal" in line and signal_dict['POS']=="init":
                signal_dict['POS'] = "long"
            if "tcashortsignal" in line and signal_dict['POS']=="init":
                signal_dict['POS'] = "short"
            a={"buy", "buyunder", "buy:", "openat", "accumulatebetween", "buyzone"}
            if any(x in line for x in a) and signal_dict['AC']=="init":
                signal_dict['AC'] = get_price_type(line, a, satoshi=satoshi_signal)
                
            if "t1:" in line and "t2:" in line and "t3:" in line :
                a_t1t2t3=line.replace("t1","")
                a_t1t2t3=a_t1t2t3.replace("t2","")
                a_t1t2t3=a_t1t2t3.replace("t3","")
                a_t1t2t3=a_t1t2t3.split(":")
                signal_dict['T1'] = float8f(float(a_t1t2t3[1]))
                signal_dict['T2'] = float8f(float(a_t1t2t3[2]))
                signal_dict['T3'] = float8f(float(a_t1t2t3[3]))
                
            if "sellingtargets:" in line:
                a_sell=line.split("sellingtargets:")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = get_price_type("t1:"+a_sell[0], {"t1", "target1"}, satoshi=satoshi_signal)
                signal_dict['T2'] = get_price_type("t2:"+a_sell[1], {"t2", "target2"}, satoshi=satoshi_signal)
                signal_dict['T3'] = get_price_type("t3:"+a_sell[2], {"t3", "target3"}, satoshi=satoshi_signal)
                if signal_dict['SL']=="init" and signal_dict['AC']<>"init":
                    signal_dict['SL'] = float8f(percentage_calc(signal_dict['AC'], dct_INI_JSON['float_percentage_max_sl']))
                
            if "shorttermtargets:" in line:
                a_sell=line.split("shorttermtargets:")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = get_price_type("t1:"+a_sell[0], {"t1", "target1"}, satoshi=satoshi_signal)
                signal_dict['T2'] = get_price_type("t2:"+a_sell[1], {"t2", "target2"}, satoshi=satoshi_signal)
                signal_dict['T3'] = get_price_type("t3:"+a_sell[2], {"t3", "target3"}, satoshi=satoshi_signal)
            elif "sell:" in line:
                a_sell=line.split("sell:")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = get_price_type("t1:"+a_sell[0], {"t1", "target1"}, satoshi=satoshi_signal)
                signal_dict['T2'] = get_price_type("t2:"+a_sell[1], {"t2", "target2"}, satoshi=satoshi_signal)
                signal_dict['T3'] = get_price_type("t3:"+a_sell[2], {"t3", "target3"}, satoshi=satoshi_signal)
            elif "sell" in line:
                a_sell=line.split("sell")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = get_price_type("t1:"+a_sell[0], {"t1", "target1"}, satoshi=satoshi_signal)
                signal_dict['T2'] = get_price_type("t2:"+a_sell[1], {"t2", "target2"}, satoshi=satoshi_signal)
                signal_dict['T3'] = get_price_type("t3:"+a_sell[2], {"t3", "target3"}, satoshi=satoshi_signal)
            a={"target1:", "t1:", "target1-"}
            if any(x in line for x in a) and signal_dict['T1']=="init":
                signal_dict['T1'] = get_price_type(line, a, satoshi=satoshi_signal)
            a={"target2:", "t2:", "target2-"}
            if any(x in line for x in a) and signal_dict['T2']=="init":
                signal_dict['T2'] = get_price_type(line, a, satoshi=satoshi_signal)
            a={"target3:", "t3:", "target3-"}
            if any(x in line for x in a) and signal_dict['T3']=="init":
                signal_dict['T3'] = get_price_type(line, a, satoshi=satoshi_signal)
            a={"stop:", "stoploss", "stoplimit:", "stop-loss:", "stoploss:", "sl"}
            if any(x in line for x in a) and signal_dict['SL']=="init":
                signal_dict['SL'] = get_price_type(line, a, satoshi=satoshi_signal)
            if signal_dict['SL']=="init" and signal_dict['AC']<>"init":
                signal_dict['SL'] = float8f(percentage_calc(signal_dict['AC'], dct_INI_JSON['float_percentage_max_sl']))

        print signal_dict
        key_not_find=0
        str_file="[TRADE]\n"
        if signal_dict['POS']<>"init":
            if signal_dict['USD']=="init": signal_dict['USD'] = ""
        else:
            if signal_dict['USD']=="init": signal_dict['USD'] = ""
        if signal_dict['POS']=="init": signal_dict['POS'] = "binance"
        for key, value in sorted(signal_dict.items()):
            if (value == 'init' or value == 'vide'):
                update.message.reply_text("Valeur non trouvee:"+key)
                key_not_find=1
            else:
                str_file=str_file+key.upper()+":"+str(value).strip()+"\n"

        if key_not_find<>1:
            if signal_dict['POS'] == "long" and not float(signal_dict['SL'])<=float(signal_dict['AC'])<=float(signal_dict['T1'])<=float(signal_dict['T2'])<=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            elif signal_dict['POS'] == "short" and not float(signal_dict['SL'])>=float(signal_dict['AC'])>=float(signal_dict['T1'])>=float(signal_dict['T2'])>=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            else:
                if signal_dict['POS']<>"init" and signal_dict['POS']<>"binance":
                    text_file = open(api_path+bitmex_signals_path+signal_dict['C'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S"), "w")
                else:
                    text_file = open(api_path+binance_signals_path+signal_dict['C'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S"), "w")
                text_file.write(str_file)
                text_file.close()
                update.message.reply_text("Signal resolu:\n"+str_file)
        else:
            update.message.reply_text("Signal non resolu!")
#            update.message.reply_text("Signal non resolu, format:\nXLMBTC\nBuy:0.01\nSell: 0.02-0.03-0.04\nStop:0.005\nUSD:100\nOu format:\nXLMBTC\nBuy:0.01\nT1:0.02\nT2:0.03\nT3:0.04\nStop Loss:0.005\nUSD:100")
    elif "PeerChannel(channel_id=1321818269)".lower() in text_sent:
        print "bitmex"
        dct_INI_JSON=load_obj(json_ini)
        symbol_dict=load_obj("bitmex_contracts.json")
#        symbol_dict = ['XBTUSD','.XRPXBT','.XRPXBT30M','.EVOL7D','.EOSXBT','.EOSXBT30M','.JPYBON','.JPYBON2H','.JPYBON8H','.BCHXBT','.BCHXBT30M','.KRWBON','.KRWBON2H','.KRWBON8H','.XBTKRWPI','.XBTKRWPI2H','.XBTKRWPI8H','.XBTKRW','.XBTKRW30M','.ADAXBT','.ADAXBT30M','.TRXXBT','.TRXXBT30M','.BADAXBT','.BADAXBT30M','.BBCHXBT','.BBCHXBT30M','.BEOSXBT','.BEOSXBT30M','.BXRPXBT','.BXRPXBT30M','BCHU18','ADAU18','EOSU18','XRPU18','TRXU18','XRPZ18','BCHZ18','ADAZ18','EOSZ18','TRXZ18','BTC/KRW','.XBT','.XBT30M','.XBTBON','.XBTBON8H','.XBTUSDPI','.XBTUSDPI8H','.XBTBON2H','.XBTUSDPI2H','.BXBT','.BXBT30M','.XBTJPY','.XBTJPY30M','.BXBTJPY','.BXBTJPY30M','.XBTJPYPI','.XBTJPYPI2H','.XBTJPYPI8H','.BVOL','.BVOL24H','.BVOL7D','.ETHXBT','.ETHXBT30M','.ETHXBTPI','.ETHXBTPI8H','.ETHBON','.ETHBON2H','.ETHBON8H','.ETHXBTPI2H','.BETH','.BETH30M','.ETHUSDPI','.ETHUSDPI2H','.ETHUSDPI8H','.BETHXBT','.BETHXBT30M','.LTCXBT','.LTCXBT30M','.BLTCXBT','.BLTCXBT30M','.USDBON','.USDBON8H','.USDBON2H','BTC/USD','XBT7D_U105','XBT7D_D95','XBTU18','XBTZ18','XBTH19','BTC/JPY','ETH/BTC','ETH/USD','ETHU18','ETHZ18','LTCU18','LTCZ18']
        signal_dict = init_dict()
        signal_dict['CHNL'] = channel
        lines = clean_text(text_sent)
        lines=lines.splitlines()
        for line in lines:
            if "PeerChannel(channel_id=".lower() in line or "PeerUser(user_id=".lower() in line:
                signal_dict['CHNL'] = line.replace("chnl:", "")
            if (line.upper() in symbol_dict or 'XBTUSD' in line.upper() or 'ETHUSD' in line.upper()) and signal_dict['C']=="init":
                signal_dict['C'] = line.upper()
            if "position:" in line and signal_dict['POS']=="init":
                signal_dict['POS'] = line.replace("position:", "")
            a={"buyaboveorin:", "buybeloworin:"}
            if any(x in line for x in a) and signal_dict['AC']=="init":
                signal_dict['AC'] = get_price_type(line, a)
            a={"target1:", "t1:"}
            if any(x in line for x in a) and signal_dict['T1']=="init":
                signal_dict['T1'] = get_price_type(line, a)
            a={"target2:", "t2:"}
            if any(x in line for x in a) and signal_dict['T2']=="init":
                signal_dict['T2'] = get_price_type(line, a)
            a={"target3:", "t3:"}
            if any(x in line for x in a) and signal_dict['T3']=="init":
                signal_dict['T3'] = get_price_type(line, a)
            a={"stop:", "stoploss:", "stoplimit:", "stop-loss:"}
            if any(x in line for x in a) and signal_dict['SL']=="init":
                signal_dict['SL'] = get_price_type(line, a)
            a={"usd:", "usdt:"}
            if any(x in line for x in a) and signal_dict['USD']=="init":
                for x in a:
                    if x in line:
                        a_usd=line.split(x)
                        signal_dict['USD'] = a_usd[1]

        print signal_dict
        key_not_find=0
        str_file="[TRADE]\n"
        if signal_dict['USD']=="init": signal_dict['USD'] = ""
        for key, value in sorted(signal_dict.items()):
            if value == 'init' or value == 'vide':
                update.message.reply_text("Valeur non trouvee:"+key)
                key_not_find=1
            else:
                str_file=str_file+key.upper()+":"+str(value).strip()+"\n"

        if key_not_find<>1:
            if signal_dict['POS'] == "long" and not float(signal_dict['SL'])<=float(signal_dict['AC'])<=float(signal_dict['T1'])<=float(signal_dict['T2'])<=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            elif signal_dict['POS'] == "short" and not float(signal_dict['SL'])>=float(signal_dict['AC'])>=float(signal_dict['T1'])>=float(signal_dict['T2'])>=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            else:
                text_file = open(api_path+bitmex_signals_path+signal_dict['C'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S"), "w")
                text_file.write(str_file)
                text_file.close()
                update.message.reply_text("Signal resolu:\n"+str_file)
        else:
            update.message.reply_text("Signal non resolu!")
#            update.message.reply_text("Signal non resolu, format:\nXLMBTC\nBuy:0.01\nSell: 0.02-0.03-0.04\nStop:0.005\nUSD:100\nOu format:\nXLMBTC\nBuy:0.01\nT1:0.02\nT2:0.03\nT3:0.04\nStop Loss:0.005\nUSD:100")
    elif "btc" in text_sent or "coin:" in text_sent:
        print "signal"
        signal_dict = init_dict()
        signal_dict['CHNL'] = channel
        lines = clean_text(text_sent)
        lines=lines.splitlines()
        for line in lines:
#Crypto Signalist Pro
            if "PeerChannel(channel_id=".lower() in line or "PeerUser(user_id=".lower() in line:
                signal_dict['CHNL'] = line.replace("chnl:", "")
            if "btc" in line and signal_dict['C']=="init":
                signal_dict['C'] = line.upper()
                if signal_dict['C'].find("("):
                    a_symbol=signal_dict['C']
                    a_symbol=a_symbol.split('(', 1)[0]
                    signal_dict['C'] = a_symbol
                if signal_dict['C'].find("-"):
                    a_symbol=signal_dict['C']
                    a_symbol=a_symbol.split('-', 1)[0]
                    signal_dict['C'] = a_symbol
            if "coin:" in line and signal_dict['C']=="init":
                a_usd=line.split("coin:")
                signal_dict['C'] = a_usd[1].upper()+"BTC"
            if "usd" in line:
                a_usd=line.split("usd:")
                signal_dict['USD'] = a_usd[1]
            if "sell:" in line:
                a_sell=line.split("sell:")
                a_sell=a_sell[1].split("-")
                signal_dict['T1'] = float8f(float(a_sell[0]))
                signal_dict['T2'] = float8f(float(a_sell[1]))
                signal_dict['T3'] = float8f(float(a_sell[2]))
            if "t1:" in line and "t2:" in line and "t3:" in line :
                a_t1t2t3=line.replace("t1","")
                a_t1t2t3=a_t1t2t3.replace("t2","")
                a_t1t2t3=a_t1t2t3.replace("t3","")
                a_t1t2t3=a_t1t2t3.split(":")
                signal_dict['T1'] = float8f(float(a_t1t2t3[1]))
                signal_dict['T2'] = float8f(float(a_t1t2t3[2]))
                signal_dict['T3'] = float8f(float(a_t1t2t3[3]))
#Signal Profits
            else:
                a={"target1:", "t1:"}
                if any(x in line for x in a):
                    if signal_dict['T1']=="init":
                        signal_dict['T1'] = get_price_type(line, a)
                    else:
                        signal_dict['T3'] = get_price_type(line, a)
                a={"target2:", "t2:"}
                if any(x in line for x in a) and signal_dict['T2']=="init":
                    signal_dict['T2'] = get_price_type(line, a)
                a={"target3:", "t3:"}
                if any(x in line for x in a):
                    signal_dict['T3'] = get_price_type(line, a)
            a={"buy:", "buyzone:", "buybelow:", "buybeloworcloseto:", "entryzone:"}
            if any(x in line for x in a) and signal_dict['AC']=="init":
                signal_dict['AC'] = get_price_type(line, a)
            a={"stop:", "stoploss:", "stoplimit:", "stop-loss:"}
            if any(x in line for x in a) and signal_dict['SL']=="init":
                signal_dict['SL'] = get_price_type(line, a)
            a={"usd:", "usdt:"}
            if any(x in line for x in a) and signal_dict['USD']=="init":
                for x in a:
                    if x in line:
                        a_usd=line.split(x)
                        signal_dict['USD'] = a_usd[1]
                
        print signal_dict
        key_not_find=0
        str_file="[TRADE]\n"
        if signal_dict['POS']=="init": signal_dict['POS'] = "binance"
        if signal_dict['USD']=="init": signal_dict['USD'] = ""
        for key, value in sorted(signal_dict.items()):
            if value == 'init' or value == 'vide':
                update.message.reply_text("Valeur non trouvee:"+key)
                key_not_find=1
            else:
                str_file=str_file+key.upper()+":"+str(value).strip()+"\n"

        if key_not_find<>1:
            if not float(signal_dict['SL'])<=float(signal_dict['AC'])<=float(signal_dict['T1'])<=float(signal_dict['T2'])<=float(signal_dict['T3']):
                update.message.reply_text("Signal false:\n"+"Check numbers\n"+str(signal_dict))
            else:
                text_file = open(api_path+binance_signals_path+signal_dict['C'].upper()+"_"+datetime.datetime.now().strftime("%Y-%m-%d_%H.%M.%S"), "w")
                text_file.write(str_file)
                text_file.close()
                update.message.reply_text("Signal resolu:\n"+str_file)
        else:
            update.message.reply_text("Signal non resolu, format:\nXLMBTC\nBuy:0.01\nSell: 0.02-0.03-0.04\nStop:0.005\nUSD:100\nOu format:\nXLMBTC\nBuy:0.01\nT1:0.02\nT2:0.03\nT3:0.04\nStop Loss:0.005\nUSD:100")
#            print str_file
    else:
        update.message.reply_text("I dont understand")
#    menu(bot)
    print "END response"
    
def error(bot, update, error):
    """Log Errors caused by Updates."""
    logger.warning('Update "%s" caused error "%s"', update, error)

def main():
    """Start the bot."""
    # Create the EventHandler and pass it your bot's token.
    global updater
    updater = Updater(dct_INI_JSON['str_my_telegram_bot_token'])
    bot = telegram.Bot(dct_INI_JSON['str_my_telegram_bot_token'])
    menu(bot)
    # Get the dispatcher to register handlers
    dp = updater.dispatcher
    # on different commands - answer in Telegram
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("menu", menu))
    dp.add_handler(CommandHandler("help", help))

    # on noncommand i.e message - echo the message on Telegram
    dp.add_handler(MessageHandler(Filters.text, echo))
    dp.add_handler(CallbackQueryHandler(button))

    # log all errors
    dp.add_error_handler(error)

    # Start the Bot
    updater.start_polling()
    
    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()

print "Starting Bot"
if __name__ == '__main__':
    main()
